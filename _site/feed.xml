<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lcl Blog</title>
    <description>关于前端与设计 | 这里是 @LCL 李成龙 的个人博客，与你一起发现更大的世界。</description>
    <link>https://lcl-101.github.io/</link>
    <atom:link href="https://lcl-101.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 17 Jul 2016 20:38:50 +0800</pubDate>
    <lastBuildDate>Sun, 17 Jul 2016 20:38:50 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>JavaScript</title>
        <description>&lt;h1 id=&quot;javascript&quot;&gt;实例：12个你未必知道的JavaScript技巧&lt;/h1&gt;
&lt;p&gt;实例：12个你未必知道的JavaScript技巧&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;使用!!操作符转换布尔值&lt;/h2&gt;
&lt;p&gt;有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回&lt;strong&gt;true&lt;/strong&gt;值。为了做这样的验证，我们可以使用&lt;strong&gt;!!&lt;/strong&gt;操作符来实现是非常的方便与简单。对于变量可以使用&lt;strong&gt;!!variable&lt;/strong&gt;做检测，只要变量的值为:&lt;strong&gt;0&lt;/strong&gt;、&lt;strong&gt;null&lt;/strong&gt;、&lt;strong&gt;”“&lt;/strong&gt;、&lt;strong&gt;undefined&lt;/strong&gt;或者&lt;strong&gt;NaN&lt;/strong&gt;都将返回的是&lt;strong&gt;false&lt;/strong&gt;，反之返回的是&lt;strong&gt;true&lt;/strong&gt;。比如下面的示例：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;function Account(cash) {
    this.cash = cash;    this.hasMoney = !!cash;
}var account = new Account(100.50);
console.log(account.cash); // 100.50console.log(account.hasMoney); // truevar emptyAccount = new Account(0);
console.log(emptyAccount.cash); // 0console.log(emptyAccount.hasMoney); // false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在这个示例中，只要&lt;strong&gt;account.cash&lt;/strong&gt;的值大于&lt;strong&gt;0&lt;/strong&gt;，那么&lt;strong&gt;account.hasMoney&lt;/strong&gt;返回的值就是true。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;使用+将字符串转换成数字&lt;/h2&gt;
&lt;p&gt;这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回&lt;strong&gt;NaN&lt;/strong&gt;，比如下面的示例：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;function toNumber(strNumber) {
    return +strNumber;
}
console.log(toNumber(&quot;1234&quot;)); // 1234console.log(toNumber(&quot;ACB&quot;)); // NaN&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个也适用于&lt;strong&gt;Date&lt;/strong&gt;，在本例中，它将返回的是时间戳数字&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;console.log(+new Date()) // 1461288164385&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-2&quot;&gt;并条件符&lt;/h2&gt;

&lt;p&gt;如果你有一段这样的代码：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if (conected) {
    login();
}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;你也可以将变量简写，并且使用&lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;和函数连接在一起，比如上面的示例，可以简写成这样：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;conected &amp;amp;&amp;amp; login();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;user &amp;amp;&amp;amp; user.login();&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-3&quot;&gt;使用||运算符&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用**&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为&lt;/strong&gt;false**，那么第二个值将会认为是一个默认值。如下面这个示例：&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;function User(name, age) {
    this.name = name || &quot;Oliver Queen&quot;;    this.age = age || 27;
}var user1 = new User();
console.log(user1.name); // Oliver Queenconsole.log(user1.age); // 27var user2 = new User(&quot;Barry Allen&quot;, 25);
console.log(user2.name); // Barry Allenconsole.log(user2.age); // 25&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;arraylength&quot;&gt;在循环中缓存&lt;strong&gt;array.length&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;for(var i = 0; i &amp;lt; array.length; i++) {
    console.log(array[i]);
}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将&lt;strong&gt;array.length&lt;/strong&gt;做一个缓存：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var length = array.length;for(var i = 0; i &amp;lt; length; i++) {
    console.log(array[i]);
}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;你也可以写在这样：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;for(var i = 0, length = array.length; i &amp;lt; length; i++) {
    console.log(array[i]);
}&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-4&quot;&gt;检测对象中属性&lt;/h2&gt;

&lt;p&gt;当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用&lt;strong&gt;document.querySelector()&lt;/strong&gt;来选择一个&lt;strong&gt;id&lt;/strong&gt;，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if (&#39;querySelector&#39; in document) {
    document.querySelector(&quot;#id&quot;);
} else {
    document.getElementById(&quot;id&quot;);
}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在这个示例中，如果&lt;strong&gt;document&lt;/strong&gt;不存在&lt;strong&gt;querySelector&lt;/strong&gt;函数，那么就会调用&lt;strong&gt;docuemnt.getElementById(“id”)&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-5&quot;&gt;获取数组中最后一个元素&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Array.prototype.slice(begin,end)&lt;/strong&gt;用来获取&lt;strong&gt;begin&lt;/strong&gt;和&lt;strong&gt;end&lt;/strong&gt;之间的数组元素。如果你不设置&lt;strong&gt;end&lt;/strong&gt;参数，将会将数组的默认长度值当作&lt;strong&gt;end&lt;/strong&gt;值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为&lt;strong&gt;begin&lt;/strong&gt;的值，那么你可以获取数组的最后一个元素。如：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var array = [1,2,3,4,5,6];
console.log(array.slice(-1)); // [6]console.log(array.slice(-2)); // [5,6]console.log(array.slice(-3)); // [4,5,6]&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-6&quot;&gt;数组截断&lt;/h2&gt;

&lt;p&gt;这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有&lt;strong&gt;10&lt;/strong&gt;个元素，但你只想只要前五个元素，那么你可以通过&lt;strong&gt;array.length=5&lt;/strong&gt;来截断数组。如下面这个示例：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var array = [1,2,3,4,5,6];
console.log(array.length); // 6array.length = 3;
console.log(array.length); // 3console.log(array); // [1,2,3]
替换所有&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-7&quot;&gt;替换所有&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;String.replace()&lt;/strong&gt;函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的&lt;strong&gt;/g&lt;/strong&gt;来模拟&lt;strong&gt;replaceAll()&lt;/strong&gt;函数功能：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var string = &quot;john john&quot;;
console.log(string.replace(/hn/, &quot;ana&quot;)); // &quot;joana john&quot;console.log(string.replace(/hn/g, &quot;ana&quot;)); // &quot;joana joana&quot;&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-8&quot;&gt;合并数组&lt;/h2&gt;

&lt;p&gt;如果你要合并两个数组，一般情况之下你都会使用&lt;strong&gt;Array.concat()&lt;/strong&gt;函数：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var array1 = [1,2,3];var array2 = [4,5,6];
console.log(array1.concat(array2)); // [1,2,3,4,5,6];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用&lt;strong&gt;Array.pus().apply(arr1,arr2)&lt;/strong&gt;来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var array1 = [1,2,3];var array2 = [4,5,6];
console.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6];&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;## 将&lt;strong&gt;NodeList&lt;/strong&gt;转换成数组&lt;/p&gt;

&lt;p&gt;如果你运行&lt;strong&gt;document.querySelectorAll(“p”)&lt;/strong&gt;函数时，它可能返回&lt;strong&gt;DOM&lt;/strong&gt;元素的数组，也就是&lt;strong&gt;NodeList&lt;/strong&gt;对象。但这个对象不具有数组的函数功能，比如&lt;strong&gt;sort()&lt;/strong&gt;、&lt;strong&gt;reduce()&lt;/strong&gt;、&lt;strong&gt;map()&lt;/strong&gt;、&lt;strong&gt;filter()&lt;/strong&gt;等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用&lt;strong&gt;[].slice.call(elements)&lt;/strong&gt;来实现：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var elements = document.querySelectorAll(&quot;p&quot;); // NodeListvar arrayElements = [].slice.call(elements); // Now the NodeList is an arrayvar arrayElements = Array.from(elements); // This is another way of converting NodeList to Array&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;数组元素的洗牌&lt;/h2&gt;

&lt;p&gt;对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var list = [1,2,3];
console.log(list.sort(function() { Math.random() - 0.5 })); // [2,1,3]&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-10&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;现在你学会了些有用的JavaScript小技巧。希望这些小技巧能在工作中帮助你解决一些麻烦，或者说这篇文章对你有所帮助。如果你有一些优秀的JavaScript小技巧，欢迎在评论中与我们一起分享。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3cplus.com/javascript/12-extremely-useful-hacks-for-javascript.html&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 17 Jul 2016 19:00:00 +0800</pubDate>
        <link>https://lcl-101.github.io/2016/07/17/JavdScript/</link>
        <guid isPermaLink="true">https://lcl-101.github.io/2016/07/17/JavdScript/</guid>
        
        <category>javascript</category>
        
        
      </item>
    
      <item>
        <title>Hello 2016</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“It’s my style. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;研究了好一会，终于把博客开通了，在这里很感谢hux提供的模版，供我们参考。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#build&quot;&gt;跳过废话，直接看技术实现 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2016 年，Lcl的博客终于开通了。&lt;/p&gt;

&lt;p&gt;从开始工作，就一想做一些的东西，但在大众博客上感觉没有大多意思，就像自己做一些东西，研究研究，正好github提供了这个平台，github page，对于程序员来说，这个着实有趣，自己用了两天的时间把它弄了清楚，下面就介绍是如何实现的。&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;接下来说说搭建这个博客的技术细节。&lt;/p&gt;

&lt;p&gt;正好之前就有关注过 &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; + &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; 快速 Building Blog 的技术方案，非常轻松时尚。&lt;/p&gt;

&lt;p&gt;其优点非常明显：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Markdown&lt;/strong&gt; 带来的优雅写作体验，我自己用的的mac本，所以提供一个免费的编写软件（MWeb Lite），用这个来写，确实很方便，可以一边编辑，一边看到自己写的内容，已经排版好的，重点是这款软件是完全免费的。&lt;/li&gt;
  &lt;li&gt;非常熟悉的 Git workflow ，&lt;strong&gt;Git Commit 即 Blog Post&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机
    &lt;ul&gt;
      &lt;li&gt;如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Jekyll 的自定制非常容易，基本就是个模版引擎&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这里提供hux提供的模版，对于新手来说，可是很快的上手&lt;a href=&quot;http://huxpro.coding.me&quot;&gt;镜像&lt;/a&gt;，网上还有很多jekll的模版，可以选一个自己喜欢的下载使用。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手&lt;/p&gt;

&lt;p&gt;大的 Jekyll 主题上直接 fork 了 Clean Blog（这个主题也相当有名，就不多赘述了。唯一的缺点大概就是没有标签支持，于是我给它补上了。）&lt;/p&gt;

&lt;p&gt;本地调试环境需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;gem install jekyll&lt;/code&gt;，但在这里有个坑，ruby被墙了，不过有万能的网友提供了解决办法，&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo gem install jekll --user--install&lt;/code&gt;,换成这句话后，很顺利的就安装成功了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;希望你们能喜欢我的博客&lt;/p&gt;

&lt;p&gt;—— lcl 后记于 2016.7&lt;/p&gt;

</description>
        <pubDate>Tue, 12 Jul 2016 17:00:00 +0800</pubDate>
        <link>https://lcl-101.github.io/2016/07/12/hello2016/</link>
        <guid isPermaLink="true">https://lcl-101.github.io/2016/07/12/hello2016/</guid>
        
        <category>生活</category>
        
        
      </item>
    
      <item>
        <title>「知乎」如何评价 MIUI 6？</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;http://www.zhihu.com/question/24783844/answer/29286896&quot;&gt;我在知乎上的回答&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div&gt;
    &lt;blockquote&gt;MIUI 6，充满了“借鉴”，iOS 7 版的 Android……
        &lt;br /&gt;米 4，碉堡了，不服跑个分，简直就是 iPhone 4……&lt;/blockquote&gt;你们说得这些我一点都不反对。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;可是，你们对小米的要求太高了&lt;/b&gt;。
    &lt;br /&gt;
    &lt;br /&gt;其实小米说到底也不过是一个才初创4年的公司而已，
    &lt;br /&gt;&lt;b&gt;你是指望小米能引领一套新的设计风格？&lt;/b&gt;
    &lt;br /&gt;&lt;b&gt;还是指望它能在国际上体现一下我国的自主创新能力？&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;你想太多了。
    &lt;br /&gt;
    &lt;br /&gt;更何况，&lt;b&gt;MIUI也不是没有设计&lt;/b&gt;，它比很多国内，国际大厂的ROM好看好用太多了。
    &lt;br /&gt;它只是没有多少新设计而已， iOS 7 的视觉，混着大部分 Android ＋ WP 的交互。也不知道是因为确实欣赏 Android 的一些交互，还是因为毕竟是基于 Android 懒得改了。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;因为没有一个背后的设计思想在支撑，于是它就把所有自己觉得好，觉得会被认可的东西抄过来了而已。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;这思路一点问题都没有，&lt;/b&gt;&lt;b&gt;大部分用户一定会觉得更好看了&lt;/b&gt;，国际范儿又有设计感。最多是少数圈内人士（包括我），那群也不真正买它手机用的人，在那愤愤不平而已。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;自立门派风险太大了。&lt;/b&gt;
    &lt;br /&gt;&lt;b&gt;MI 4 的配置 + MIUI 6，在这个价位几乎是无敌的，这就够了。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;至于官方说的什么“糖果式”设计，那简直就是笑话。跟 Ive 的 iOS 7 或是 Material Design，Metro 所设计之设计，完全不在一个高度上。
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;其实有的时候觉得小米很像腾讯（尤其是更早些年的腾讯）。
    &lt;br /&gt;&lt;b&gt;其实本来也就不是什么创新者的角色，那就做借鉴和整合呗。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;用户喜欢什么，
    &lt;br /&gt;公司需要什么，
    &lt;br /&gt;大众流行什么，
    &lt;br /&gt;那我们就做呗。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;拿下市场才是第一位的，不出错才是第一位的&lt;/b&gt;。
    &lt;br /&gt;&lt;b&gt;先做大了才有可能去做更大的事啊&lt;/b&gt;。
    &lt;br /&gt;
    &lt;br /&gt;老罗再有情怀，锤子要是死了，那也就这么死了。
    &lt;br /&gt;
    &lt;br /&gt;你指责小米没有多少创新，或是腾讯老是山寨 start up ，我同意，我陪你愤愤不平，可是又有什么意思呢。
    &lt;br /&gt;
    &lt;br /&gt;它们这么做，对现有公司发展来说，
    &lt;br /&gt;&lt;b&gt;简直是一点错都没有。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 16 Aug 2014 20:00:00 +0800</pubDate>
        <link>https://lcl-101.github.io/2014/08/16/miui6/</link>
        <guid isPermaLink="true">https://lcl-101.github.io/2014/08/16/miui6/</guid>
        
        <category>MIUI</category>
        
        
      </item>
    
  </channel>
</rss>
