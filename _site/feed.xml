<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LCL Blog</title>
    <description>我是一个coder,但是我爱物理。</description>
    <link>lcl.itmadman.cn/</link>
    <atom:link href="lcl.itmadman.cn/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 07 Jul 2016 17:40:02 +0800</pubDate>
    <lastBuildDate>Thu, 07 Jul 2016 17:40:02 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Android反编译总结</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;工欲善其事必先利其器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;Android反编译需要用到一些工具，使用这些工具可以大大的提高我们的工作效率。当然使用工具是一把双刃剑，一方面工具使我们的工作更方便，但另一方面工具把一些原理封装了起来，不利于我们的学习。所以使用工具的时候最好对工具的原理有一定的了解。&lt;/p&gt;

&lt;h2 id=&quot;jadx&quot;&gt;jadx&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/skylot/jadx&quot;&gt;github地址&lt;/a&gt;，jadx是一个将android 的dex文件解码为java的工具。并且有GUI，用起来非常的方便,具体的使用可以看官方的文档。&lt;/p&gt;

&lt;h2 id=&quot;apktool&quot;&gt;apktool&lt;/h2&gt;

&lt;p&gt;有了上面的工具，可以很方便的将apk的源码进行反编译，让我们了解代码的逻辑。但是这还远远不够，比如我们想干点坏事，将apk反编译后，做点手脚，并把它重新打包发布出去，要实现这样的功能，光上面的工具已经达不到我们的要求了。我们需要另外一个更加强大的工具－&lt;a href=&quot;http://ibotpeaches.github.io/Apktool/install/&quot;&gt;apktool&lt;/a&gt;.  apktool可以将dex文件反编译成smali文件。如果对smali语法熟悉，就可以在smali中修改app的逻辑。其实apktool这个工具集成了另外一个开源的项目&lt;a href=&quot;https://github.com/JesusFreke/smali&quot;&gt;baksmali&lt;/a&gt;，(因为apktool集成了baksmail， 假如baksmail修复了bug，需要一段时间才能集成的apktool中，所以我们也可以直接使用baksmail)&lt;/p&gt;

&lt;h2 id=&quot;smali&quot;&gt;smali语法&lt;/h2&gt;

&lt;p&gt;为了达到我们对一个apk做手脚的目的，需要了解一种新的语言smali, smail语言类似与汇编语言，如果对汇编比较熟悉的学习起来会比较容易。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;实战&lt;/h2&gt;

&lt;p&gt;下面就举个例子，演示一下怎么利用apktool解包，修改smali文件，重新打包，签名的过程。&lt;/p&gt;

&lt;p&gt;首先新建个项目，主要一个MainActivity，里面只有一个字符串，我的目的就是通过解包apk,在smali语法中注入日志打印语句，把这个字符串打印出来:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        String hello = &quot;Hello World&quot;;

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将项目打包出来的apk（debug包和release包都可以）拷贝到apktool的同级目录&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xrrm5.com1.z0.glb.clouddn.com/blog_pic_article_decompile_apk_1.png&quot; alt=&quot;目录&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后将apk包用apktool，反编译，命令为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
cfp@cfp:~/tools/android_tools/apktool$ ./apktool d app-release.apk 

I: Using Apktool 2.1.1 on app-release.apk

I: Loading resource table...

I: Decoding AndroidManifest.xml with resources...

I: Loading resource table from file: /home/cfp/apktool/framework/1.apk

I: Regular manifest package...

I: Decoding file-resources...

I: Decoding values */* XMLs...

I: Baksmaling classes.dex...

I: Copying assets and libs...

I: Copying unknown files...

I: Copying original files...

cfp@cfp:~/tools/android_tools/apktool$ 

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;反编译后多了个app-release目录，反编译的文件就都在里边了，下面的任务就是找到MainActivity，在里边注入日志打印语言，将里边的字符串输出。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
cfp@cfp:~/tools/android_tools/apktool$ ls

apktool      app-release      debug.keystore  sign.jar

apktool.jar  app-release.apk  signapk.jar

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;反编译后的目录：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
cfp@cfp:~/tools/android_tools/apktool/app-release$ ls

AndroidManifest.xml  apktool.yml  original  res  smali

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所有的smali文件都在smali目录下，我们找到MainActivity.smali文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
cfp@cfp:~/tools/android_tools/apktool/app-release/smali/com/xray/smali$ ls

BuildConfig.smali   R$bool.smali      R$id.smali       R.smali

MainActivity.smali  R$color.smali     R$integer.smali  R$string.smali

R$anim.smali        R$dimen.smali     R$layout.smali   R$styleable.smali

R$attr.smali        R$drawable.smali  R$mipmap.smali   R$style.smali

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;MainActivity.smali文件中的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
.class public Lcom/xray/smali/MainActivity;　＃class的名字

.super Landroid/support/v7/app/AppCompatActivity;　＃这个类的父类

.source &quot;MainActivity.java&quot;　＃这个类的java文件名





# direct methods

.method public constructor &amp;lt;init&amp;gt;()V　＃这个类的构造方法

    .locals 0



    .prologue

    .line 7　＃行号

    invoke-direct {p0}, Landroid/support/v7/app/AppCompatActivity;-&amp;gt;&amp;lt;init&amp;gt;()V　＃调用父类的构造方法



    return-void　＃返回空

.end method





# virtual methods

.method protected onCreate(Landroid/os/Bundle;)V　＃onCreate方法

    .locals 2

    .param p1, &quot;savedInstanceState&quot;    # Landroid/os/Bundle;　#方法的参数



    .prologue

    .line 11

    invoke-super {p0, p1}, Landroid/support/v7/app/AppCompatActivity;-&amp;gt;onCreate(Landroid/os/Bundle;)V　

＃父类的构造方法





    .line 12

    const v1, 0x7f040019



    invoke-virtual {p0, v1}, Lcom/xray/smali/MainActivity;-&amp;gt;setContentView(I)V　#调用serContentView方法



    .line 13

    const-string v0, &quot;Hello World&quot;　＃字符串Hello World，保存在寄存器v0中



    .line 15

    .local v0, &quot;hello&quot;:Ljava/lang/String;　＃变量hello ,类型为String

    return-void

.end method





&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前面说了smali语言有点像汇编，通过上面的注释大概能了解这个smali文件的大概意思，要想输出Hello World，我么可以加上调用Log的smali语句。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
const-string v1, &quot;TAG&quot;

invoke-static {v1, v0}, Landroid/util/Log;-&amp;gt;d(Ljava/lang/String;Ljava/lang/String;)I

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改后的MainActivity.smali文件变成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
.class public Lcom/xray/smali/MainActivity;　＃class的名字

.super Landroid/support/v7/app/AppCompatActivity;　＃这个类的父类

.source &quot;MainActivity.java&quot;　＃这个类的java文件名





# direct methods

.method public constructor &amp;lt;init&amp;gt;()V　＃这个类的构造方法

    .locals 0



    .prologue

    .line 7　＃行号

    invoke-direct {p0}, Landroid/support/v7/app/AppCompatActivity;-&amp;gt;&amp;lt;init&amp;gt;()V　＃调用父类的构造方法



    return-void　＃返回空

.end method





# virtual methods

.method protected onCreate(Landroid/os/Bundle;)V　＃onCreate方法

    .locals 2

    .param p1, &quot;savedInstanceState&quot;    # Landroid/os/Bundle;　#方法的参数



    .prologue

    .line 11

    invoke-super {p0, p1}, Landroid/support/v7/app/AppCompatActivity;-&amp;gt;onCreate(Landroid/os/Bundle;)V　

＃父类的构造方法





    .line 12

    const v1, 0x7f040019



    invoke-virtual {p0, v1}, Lcom/xray/smali/MainActivity;-&amp;gt;setContentView(I)V　#调用serContentView方法



    .line 13

    const-string v0, &quot;Hello World&quot;　＃字符串Hello World，保存在寄存器v0中



    .line 15

    .local v0, &quot;hello&quot;:Ljava/lang/String;　＃变量hello ,类型为String

    const-string v1, &quot;TAG&quot;

    invoke-static {v1, v0}, Landroid/util/Log;-&amp;gt;d(Ljava/lang/String;Ljava/lang/String;)I

    return-void

.end method

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后重新打包:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
cfp@cfp:~/tools/android_tools/apktool$ ./apktool b app-release

I: Using Apktool 2.1.1

I: Checking whether sources has changed...

I: Smaling smali folder into classes.dex...

I: Checking whether resources has changed...

I: Building resources...

I: Building apk file...

I: Copying unknown files/dir...

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;新的apk包位于&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
app-release/dist

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个apk包是不能直接安装的，需要用签名工具签名，可以使用另外一个工具&lt;a href=&quot;https://github.com/appium/sign&quot;&gt;sign.jar&lt;/a&gt;,命令为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
cfp@cfp:~/tools/android_tools/apktool$ java -jar sign.jar app-release.apk 



&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;签名后的新包叫app-release.s.apk，直接安装就可以打印Hello World的日志了。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
05-25 22:56:25.725 17277-17277/com.xray.smali D/TAG: Hello World

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参考文献&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.isming.me/2015/01/14/android-decompile-smali/&quot;&gt;smali语法&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://drops.wooyun.org/papers/6045&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 26 May 2016 20:00:00 +0800</pubDate>
        <link>lcl.itmadman.cn/2016/05/26/apk-decomplie/</link>
        <guid isPermaLink="true">lcl.itmadman.cn/2016/05/26/apk-decomplie/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>Retrofit介绍</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;Retrofit是Square开发的一个用于网络请求的开源库，内部封装了okhttp,并且和RxAndroid完美的兼容，使得Android的开发效率增加不少的同时也使代码变得清晰易读。&lt;/p&gt;

&lt;h2 id=&quot;gradle-&quot;&gt;Gradle 依赖&lt;/h2&gt;

&lt;p&gt;retrofit可以很方便的使用Maven和Gradle依赖，在1.x时retrofit默认是没有引入okhttp作为http client,需要手动的依赖。但是2.0版本已经将okhttp作为retrofit的默认http client,引入retrofit2只需要在gradle中配置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
compile &#39;com.squareup.retrofit2:retrofit:2.0.0&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你不想使用retrofit2中自带的okhttp，你也可以导入你自己的okhttp,为了避免导入冲突可以按下面的依赖：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
compile (&#39;com.squareup.retrofit2:retrofit:2.0.0&#39;) {  

  exclude module: &#39;okhttp&#39;
}
compile &#39;com.squareup.okhttp3:okhttp:3.2.0&#39;  

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;retrofit2默认没有导入gson,需要gson作为转换器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
compile &#39;com.squareup.retrofit2:converter-gson:2.0.0&#39; 

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与RxAndroid使用需要依赖：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
compile &#39;com.squareup.retrofit2:adapter-rxjava:2.0.0&#39;  
compile &#39;io.reactivex:rxandroid:1.0.1&#39;

﻿

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;请求参数注解说明&lt;/h2&gt;

&lt;h4 id=&quot;query-querymap&quot;&gt;@Query @QueryMap&lt;/h4&gt;

&lt;p&gt;Http Get请求参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
@GET(&quot;group/users&quot;)
Call&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; groupList(@Query(&quot;id&quot;) int groupId);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等同于&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
@GET(&quot;group/users?id=groupId&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;多个请求参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

@GET(&quot;group/{id}/users&quot;)
Call&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; groupList(@Path(&quot;id&quot;) int groupId, @QueryMap Map&amp;lt;String, String&amp;gt; options);


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;field&quot;&gt;@Field&lt;/h4&gt;

&lt;p&gt;用于Post方式传递参数,需要在请求接口方法上添加@FormUrlEncoded,表示以表单的方式传递参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
@FormUrlEncoded
@POST(&quot;user/edit&quot;)
Call&amp;lt;User&amp;gt; updateUser(@Field(&quot;first_name&quot;) String first, @Field(&quot;last_name&quot;) String last);


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;path&quot;&gt;@Path&lt;/h4&gt;

&lt;p&gt;用于URL占位符&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
@GET(&quot;group/{id}/users&quot;)
Call&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; groupList(@Path(&quot;id&quot;) int groupId);


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;header&quot;&gt;@Header&lt;/h4&gt;

&lt;p&gt;添加http header&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
@GET(&quot;user&quot;)
Call&amp;lt;User&amp;gt; getUser(@Header(&quot;Authorization&quot;) String authorization)


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;body&quot;&gt;@Body&lt;/h4&gt;

&lt;p&gt;请求体，对象会被自动转化成Json格式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

@POST(&quot;users/new&quot;)
Call&amp;lt;User&amp;gt; createUser(@Body User user);


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;interceptor&quot;&gt;拦截器Interceptor&lt;/h2&gt;

&lt;p&gt;retrofit2默认的集成了okhttp, okhttp可以设置拦截器，比如个请求添加统一的Header&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
httpClient.addNetworkInterceptor(new Interceptor() {
    @Override
    public Response intercept(Chain chain) throws IOException {

        Request request = chain.request();
        Request.Builder requestBuilder = request.newBuilder().addHeader(&quot;Accept&quot;, &quot;application/json&quot;);
        Request request1 = requestBuilder.build();

        return chain.proceed(request);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;post&quot;&gt;Post多个参数提交&lt;/h4&gt;

&lt;p&gt;如果有很多默认的参数需要每次添加时：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
@FormUrlEncoded
@POST(&quot;/feedback&quot;)
Call&amp;lt;ResponseBody&amp;gt; sendFeedbackSimple(  
    @Field(&quot;osName&quot;) String osName,
    @Field(&quot;osVersion&quot;) int osVersion,
    @Field(&quot;device&quot;) String device,
    @Field(&quot;message&quot;) String message,
    @Field(&quot;userIsATalker&quot;) Boolean userIsATalker);



&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
private void sendFeedbackFormSimple(@NonNull String message) {  
    // create the service to make the call, see first Retrofit blog post
    FeedbackService taskService = ServiceGenerator.create(FeedbackService.class);

    // create flag if message is especially long
    boolean userIsATalker = (message.length() &amp;gt; 200);

    Call&amp;lt;ResponseBody&amp;gt; call = taskService.sendFeedbackSimple(
            &quot;Android&quot;,
            android.os.Build.VERSION.SDK_INT,
            Build.MODEL,
            message,
            userIsATalker
    );

    call.enqueue(new Callback&amp;lt;ResponseBody&amp;gt;() {
        ...
    });
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以写成下面的形式:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
@POST(&quot;/feedback&quot;)
Call&amp;lt;ResponseBody&amp;gt; sendFeedbackConstant(@Body UserFeedback feedbackObject);  


public class UserFeedback {

    private String osName = &quot;Android&quot;;
    private int osVersion = android.os.Build.VERSION.SDK_INT;
    private String device = Build.MODEL;
    private String message;
    private boolean userIsATalker;

    public UserFeedback(String message) {
        this.message = message;
        this.userIsATalker = (message.length() &amp;gt; 200);
    }

    // getters &amp;amp; setters
    // ...
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;


private void sendFeedbackFormAdvanced(@NonNull String message) {  
    FeedbackService taskService = ServiceGenerator.create(FeedbackService.class);

    Call&amp;lt;ResponseBody&amp;gt; call = taskService.sendFeedbackConstant(new UserFeedback(message));

    call.enqueue(new Callback&amp;lt;ResponseBody&amp;gt;() {
        ...
    });
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;retrofit2--rxandroid-&quot;&gt;Retrofit2 + RxAndroid 封装和使用&lt;/h2&gt;

&lt;p&gt;首先创建一个工厂类根据不通的api interface 创建其实现。这个解释起来比较抽象，可以看下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
/**
 * Created by cfp on 16-4-18.
 */
public class RetrofitFactory {


    public static final String GITHUB_HTTP_URL = &quot;https://api.github.com&quot;;

    public static final String OTHER_HTTP_URL = &quot;https://yoursite&quot;;


    //默认超时时间
    private final static int DEFAULT_TIMEOUT = 5;

    private static OkHttpClient.Builder httpClient = new OkHttpClient.Builder();

    private static Retrofit.Builder githubBuilder = new Retrofit.Builder()
            .baseUrl(GITHUB_HTTP_URL)
            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
            .addConverterFactory(GsonConverterFactory.create());


    private static Retrofit.Builder otherBuilder = new Retrofit.Builder()
            .baseUrl(OTHER_HTTP_URL)
            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
            .addConverterFactory(GsonConverterFactory.create());

    /**
     * 为了防止一个类里放置所有的api,可以根据程序的功能分成不通的模块，把他们存在map中
     */
    private static Map&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt; githubApiMap = new HashMap&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt;();
    private static Map&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt; otherApiMap = new HashMap&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt;();


    /**
     * 默认的server为github
     *
     * @param instanceClass
     * @param &amp;lt;S&amp;gt;
     * @return
     */
    public synchronized static &amp;lt;S&amp;gt; S getInstance(Class&amp;lt;S&amp;gt; instanceClass) {

        return getInstance(GITHUB_HTTP_URL, instanceClass);
    }


    public RetrofitFactory() {
    }

    public synchronized static &amp;lt;S&amp;gt; S getInstance(String server, Class&amp;lt;S&amp;gt; instanceClass) {

        final Retrofit retrofit;

        switch (server) {

            case GITHUB_HTTP_URL:

                if (githubApiMap.containsKey(instanceClass)) {

                    return (S) githubApiMap.get(instanceClass);
                } else {
                    //添加拦截器，可以给请求添加header
                    httpClient.addNetworkInterceptor(new Interceptor() {
                        @Override
                        public Response intercept(Chain chain) throws IOException {

                            Request origin = chain.request();
                            Request.Builder requestBuilder = origin.newBuilder()
                                    .addHeader(&quot;devicetype&quot;, &quot;ANDROID&quot;);
                            Request request = requestBuilder.build();

                            return chain.proceed(request);
                        }
                    });
                    retrofit = githubBuilder.client(httpClient.build()).build();
                    S instance = retrofit.create(instanceClass);
                    githubApiMap.put(instanceClass, instance);
                    return instance;


                }
            case OTHER_HTTP_URL:

                if (otherApiMap.containsKey(instanceClass)) {

                    return (S) githubApiMap.get(instanceClass);
                } else {

                    retrofit = githubBuilder.client(httpClient.build()).build();
                    S instance = retrofit.create(instanceClass);
                    otherApiMap.put(instanceClass, instance);
                    return instance;
                }

            default:
                return null;

        }

    }
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外就是网络请求的抽象回调类，继承自Subscriber&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
/**
 * 网络请求的回调抽象类
 * Created by cfp on 16-5-24.
 */
public abstract class AbsCallBackSubscriber&amp;lt;T&amp;gt; extends Subscriber&amp;lt;T&amp;gt; {
    @Override
    public void onCompleted() {

        //解除注册
        if (this.isUnsubscribed()){

            this.unsubscribe();
        }
        onFinish();
    }

    @Override
    public void onError(Throwable e) {
        // TODO: 16-5-25 一些错误处理
    }

    @Override
    public void onNext(T t) {
        onSuccess(t);
    }

    public abstract void onFinish();
    public abstract void onSuccess(T t);

}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后是真正的网络请求部分，如果有需求某次请求的错误信息需要单独处理，可以复写&lt;/p&gt;

&lt;p&gt;AbsCallBackSubscriber中的onError方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
RetrofitFactory.getInstance(GithubApi.class).getFollowings(username)
        .subscribeOn(Schedulers.io())
        .unsubscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new AbsCallBackSubscriber&amp;lt;List&amp;lt;UserInfo&amp;gt;&amp;gt;() {
            @Override
            public void onFinish() {

            }

            @Override
            public void onSuccess(List&amp;lt;UserInfo&amp;gt; userInfos) {

            }
        });


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后是接口的interface&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
/**
 * Created by cfp on 16-4-18.
 */
public interface GithubApi {

    @GET(&quot;/users/{username}&quot;)
    Observable&amp;lt;UserInfo&amp;gt; getUserInfo(@Path(&quot;username&quot;) String username);
    @GET(&quot;/users/{username}/following&quot;)
    Observable&amp;lt;List&amp;lt;UserInfo&amp;gt;&amp;gt; getFollowings(@Path(&quot;username&quot;) String username);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;retrofit2 + reAndroid简单的流程用法差不多介绍了，也做了个简单的封装，至于更高级的用法，还需要继续的研究，也希望大家多多交流，指出不足共同进步^v^。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;引用&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.loongwind.com/archives/242.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://xiuweikang.github.io/2016/03/17/Retrofit%E5%88%86%E4%BA%AB/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://futurestud.io/blog/retrofit-2-upgrade-guide-from-1-9&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 25 Apr 2016 20:00:00 +0800</pubDate>
        <link>lcl.itmadman.cn/2016/04/25/retrofit_introduce/</link>
        <guid isPermaLink="true">lcl.itmadman.cn/2016/04/25/retrofit_introduce/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>2016年书单</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;读完&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://git-scm.com/book/zh/v2&quot;&gt;Pro-Git&lt;/a&gt; 作者是github的创始人&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/vamei/archive/2012/12/05/2802811.html&quot;&gt;协议森林&lt;/a&gt;用很直白但却很形象的文字帮助读者了解网络协议，读过这一系列文章后，你可以找到参考书籍，继续深入学习。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/vamei/archive/2012/09/13/2682778.html&quot;&gt;Python快速教程&lt;/a&gt; 文中代码主要基于python2.7.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;在读&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1088054/&quot;&gt;TCP/IP详解　卷一：协议&lt;/a&gt; 不多说了该领域的经典&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26649050/&quot;&gt;App研发录&lt;/a&gt; 进阶必备&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26599538/&quot;&gt;Android开发艺术探索&lt;/a&gt; 侧重于Android知识的体系化和体统工作机制的分析。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md&quot;&gt;命令行的艺术&lt;/a&gt;　　步入大神的行列&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;想读&lt;/h2&gt;
</description>
        <pubDate>Wed, 23 Mar 2016 20:00:00 +0800</pubDate>
        <link>lcl.itmadman.cn/2016/03/23/2016%E4%B9%A6%E5%8D%95/</link>
        <guid isPermaLink="true">lcl.itmadman.cn/2016/03/23/2016%E4%B9%A6%E5%8D%95/</guid>
        
        <category>生活</category>
        
        
      </item>
    
      <item>
        <title>Base64编码解析</title>
        <description>&lt;h2 id=&quot;base64&quot;&gt;Base64原理简介&lt;/h2&gt;

&lt;p&gt;Base64是一种基于６４个可打印字符来表示二进制数据的表示方法，严格来讲并不是加密方法，仅仅是表示方法。由于每６bit为一个单元。三个字节有24个bit，对应于４个Base64单元&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xrrm5.com1.z0.glb.clouddn.com/blog_pic_article_2016-03-11-base64-1.png&quot; alt=&quot;Base64索引表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这么说可能稍微有点抽象，举个例子就明白了，比如 “Man” 这个单词由3个字节，也就是24bit组成,按我们前面说的如果用Base64编码的话，由４个Base64单元组成。具体可以看下面的图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xrrm5.com1.z0.glb.clouddn.com/blog_pic_article_2016-03-11-base64-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以”Man”这个单词用Base64编码的结果为”TWFu”&lt;/p&gt;

&lt;p&gt;但是我们举得这个例子有点特殊，“Man”正好有3个字节，24bit正好转成４个Base64,　如果转码的数据不是３的倍数。&lt;/p&gt;

&lt;p&gt;最后会多长１个或２个字节，那么可以使用下面的方法处理：先使用０字节值在末尾补足，使其能够被３整除，然后再进行base64的编码。在编码后的base64文本后加上一个或两个‘＝’号，代表补足的字节数。也就是说，当最后剩余一个八位字节（一个byte）时，最后一个6位的base64字节块有四位是0值，最后附加上两个等号；如果最后剩余两个八位字节（2个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;编码&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;在终端命令行中编字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
echo &quot;hello&quot; | base64

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;注：在Ubuntu上使用　echo “hello”&lt;/td&gt;
      &lt;td&gt;base64 时或出现多编码字符的情况，这个是因为UTF-8编码的原因&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;从指定的文件file中读取数据，编码为base64字符串输出。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
base64 file

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从标准输入中读取已经进行base64编码的内容，解码输出。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;base64 -d
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 09 Mar 2016 20:00:00 +0800</pubDate>
        <link>lcl.itmadman.cn/2016/03/09/Base64%E7%BC%96%E7%A0%81%E8%A7%A3%E6%9E%90/</link>
        <guid isPermaLink="true">lcl.itmadman.cn/2016/03/09/Base64%E7%BC%96%E7%A0%81%E8%A7%A3%E6%9E%90/</guid>
        
        <category>加密</category>
        
        
      </item>
    
      <item>
        <title>Php笔记-基础语法</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;变量&lt;/h2&gt;
&lt;p&gt;php 的变量必须用$开头&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$myAge
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;switch&quot;&gt;switch语法&lt;/h2&gt;
&lt;p&gt;switch有两种语法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;正常的语法：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
        $myAge = 25;
        switch($myAge){
            case 20:
                print &quot;your are age is 20&quot;;
                break;
            case 24:
                print &quot;your are age is 24&quot;;
                break;
            case 25:
                print &quot;your are age is 25&quot;;
                break;
            default:
                print &quot;your are age is not match&quot;;
                break;
      
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;sugar语法：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
        $myAge = 25;
        switch($myAge):
            case 20:
                print &quot;your are age is 20&quot;;
                break;
            case 24:
                print &quot;your are age is 24&quot;;
                break;
            case 25:
                print &quot;your are age is 25&quot;;
                break;
            default:
                print &quot;your are age is not match&quot;;
                break;
        endswitch;
    ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;数组&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $array = array(&quot;cheng&quot;, &quot;fang&quot;, &quot;peng&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;#### 获取数组的值有两种方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过[]&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$array[2]；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;通过{}&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $array{2}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;数组中删除元素&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unset(array[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;?php
        $languages = array(&quot;HTML/CSS&quot;,
        &quot;JavaScript&quot;, &quot;PHP&quot;, &quot;Python&quot;, &quot;Ruby&quot;);
      
        unset($languages[3]);
                    
        foreach($languages as $lang) {
          print &quot;&amp;lt;p&amp;gt;$lang&amp;lt;/p&amp;gt;&quot;;
        }
        /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;for&quot;&gt;for循环&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;?php
        // 输出前五个偶数
        for ($i = 2; $i &amp;lt; 11; $i = $i + 2) {
          echo $i;
        }
      ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;foreach&quot;&gt;foreach循环&lt;/h2&gt;
&lt;p&gt;foreach循环是迭代对象里的每一个元素。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;?php
          $langs = array(&quot;JavaScript&quot;,
          &quot;HTML/CSS&quot;, &quot;PHP&quot;,
          &quot;Python&quot;, &quot;Ruby&quot;);
        
          foreach ($langs as $lang) {
              echo &quot;&amp;lt;li&amp;gt;$lang&amp;lt;/li&amp;gt;&quot;;
          }
        
          unset($lang);
        ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;while-&quot;&gt;while 循环&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
	$headCount = 0;
	$flipCount = 0;
	while ($headCount &amp;lt; 3) {
		$flip = rand(0,1);
		$flipCount ++;
		if ($flip){
			$headCount ++;
			echo &quot;&amp;lt;div class=\&quot;coin\&quot;&amp;gt;H&amp;lt;/div&amp;gt;&quot;;
		}
		else {
			$headCount = 0;
			echo &quot;&amp;lt;div class=\&quot;coin\&quot;&amp;gt;T&amp;lt;/div&amp;gt;&quot;;
		}
	}
	echo &quot;&amp;lt;p&amp;gt;It took {$flipCount} flips!&amp;lt;/p&amp;gt;&quot;;
	?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;endwhile&quot;&gt;endwhile的使用&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
	 $isLoop = true;
	 $index = 0;
    while($isLoop):
        if($index &amp;gt; 10){
            $isLoop = false;
            }
            echo $index;
            $index++;
    endwhile;
        ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;do-while&quot;&gt;do-while的使用&lt;/h4&gt;

&lt;p&gt;先执行do中的代码，然后再执行while循环&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
	$flipCount = 0;
	do {
		$flip = rand(0,1);
		$flipCount ++;
		if ($flip){
			echo &quot;&amp;lt;div class=\&quot;coin\&quot;&amp;gt;H&amp;lt;/div&amp;gt;&quot;;
		}
		else {
			echo &quot;&amp;lt;div class=\&quot;coin\&quot;&amp;gt;T&amp;lt;/div&amp;gt;&quot;;
		}
	} while ($flip);
	$verb = &quot;were&quot;;
	$last = &quot;flips&quot;;
	if ($flipCount == 1) {
		$verb = &quot;was&quot;;
		$last = &quot;flip&quot;;
	}
	echo &quot;&amp;lt;p&amp;gt;There {$verb} {$flipCount} {$last}!&amp;lt;/p&amp;gt;&quot;;
	?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;函数&lt;/h2&gt;

&lt;h4 id=&quot;section-4&quot;&gt;字符串内建函数&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;strlen 返回字符串的长度&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;?php
        $name = &quot;chengfangpeng&quot;;
        print strlen($name);
    ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;substr 截取字符串函数，返回截取到的子字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;?php
       $name = &quot;chengfangpeng&quot;;
	    print substr($name, 5, 10);
    ?&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;strtoupper 将字符串转为大写&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;?php

    $name = &quot;chengfangpeng&quot;;
    print strtoupper($name);
    ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;strtolower 将字符串转为小写&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;?php
    $name = &quot;CHENGFANGPENG&quot;;
    print strtolower($name);
    ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;strpos 找出字符串中某个子字符串的位置，如果没有所给的字符串，返回false，否则返回子字符串在原字符串中的位置。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;?php
   
    $name = &quot;chengfangpeng&quot;;
    print strpos($name, &quot;fang&quot;);
    
	if(strpos($name, &quot;Hello&quot;) === false){
        print &quot;no match string&quot;;
    }
    ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-5&quot;&gt;数学内建函数&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;round 将一个float类型的数，四舍五入为整形，如果再传入保留位数参数可以转化成保留小数位的float类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;?php
      print round(M_PI); //3
      print round(M_PI, 3);//3.142
    ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//使用rand，strlen，substr函数随机打印你姓名中的一个字母
 &amp;lt;?php
  
    $name = &quot;chengfangpeng&quot;;
    $rIndex = rand(0, strlen($name));
    print substr($name, $rIndex, 1);
    ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 09 Mar 2016 20:00:00 +0800</pubDate>
        <link>lcl.itmadman.cn/2016/03/09/Php%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
        <guid isPermaLink="true">lcl.itmadman.cn/2016/03/09/Php%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
        
        <category>Php</category>
        
        
      </item>
    
      <item>
        <title>Ubuntu安装Fiddler</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;Fiddler 是Windows上一个非常强大的抓包工具，其实在Ubuntu上也是可以安装的，具体的方法如下：&lt;/p&gt;

&lt;h2 id=&quot;mono&quot;&gt;安装mono&lt;/h2&gt;
&lt;p&gt;fiddler是基于.net开发，所以安装fidder前需要安装.net framework。而.net framework 只能运行在windows，针对linux和mac操作系统，可通过安装mono framework 来支持fiddler运行。
安装命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install  mono-complete
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;fiddler&quot;&gt;下载Fiddler&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://fiddler.wikidot.com/mono&quot;&gt;下载地址&lt;/a&gt;
下载Fiddler for Mono Current Linux build
解压&lt;/p&gt;

&lt;h2 id=&quot;fiddler-1&quot;&gt;运行Fiddler&lt;/h2&gt;
&lt;p&gt;进入解压目录直接运行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./fiddler.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;就可以使用了。&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2016 20:00:00 +0800</pubDate>
        <link>lcl.itmadman.cn/2016/02/21/Ubuntu%E5%AE%89%E8%A3%85Fiddler/</link>
        <guid isPermaLink="true">lcl.itmadman.cn/2016/02/21/Ubuntu%E5%AE%89%E8%A3%85Fiddler/</guid>
        
        <category>Ubuntu</category>
        
        
      </item>
    
      <item>
        <title>Ubuntu科学上网服务器搭建</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;受天朝GFW的影响，包括大Google在内的很多境外网站访问不了，所以天朝的程序猿大多都练就了一种叫”翻墙”的功夫.从自由门，配置host，到goAgent，再到现在各色各样的vpn，翻墙的姿势也随着时代的发展发生着变化。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工具&lt;/h2&gt;
&lt;p&gt;代理服务器：&lt;a href=&quot;https://bandwagonhost.com/&quot;&gt;搬瓦工&lt;/a&gt;（我租的是每月5刀的，1T的流量，对于个人用绰绰有余了）
系统：Ubuntu 14.04
代理工具：&lt;a href=&quot;https://github.com/ziggear/shadowsocks&quot;&gt;shadowsocks&lt;/a&gt; (项目的原作者去年被请去喝茶，所以停止更新了，但是相信一个shadowsocks倒下去，成千上万的shadowsocks会站起来)&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;配置服务器&lt;/h2&gt;
&lt;p&gt;1.先到&lt;a href=&quot;https://bandwagonhost.com/&quot;&gt;搬瓦工&lt;/a&gt;租个云服务器，类似国内的阿里云，腾讯云。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160120125049014&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后就是购买的一些流程，比如让你选择服务器的位置（我选的是洛杉矶）还有就是些你的用户信息，支付的时候意外的发现搬瓦工居然支持支付宝，这一点很方便。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160120125809421&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160120131032094&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160120131245223&quot; alt=&quot;填写一些用户信息&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160120131649416&quot; alt=&quot;支付环节&quot; /&gt;&lt;/p&gt;

&lt;p&gt;支付成功后到Client Area-&amp;gt;Service-&amp;gt;MyService-&amp;gt;KiWiControl Panel
就可以看到你服务器的配置信息了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160120132507809&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160120132549684&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160120132614978&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后的工作就是在服务器上安装shadowsocks.
通过终端ssh到服务器，在Ubuntu上安装shadowsocks比较方便，shadowsocks使用python写的（当然也有其他版本的，例如：go语言的），所以需要一个管理python包的工具PIP，安装PIP的命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~# apt–get install python–gevent python–pip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后可以直接安装 shadowsocks 了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~# pip install shadowsocks
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后就是配置shadowsocks，自己写个配置文件/etc/shadowsocks.json&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;server&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;你服务器的ip&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;server_port&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8388&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;密码&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;timeout&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;method&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;aes-256-cfb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;fast_open&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;workers&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;server: 你自己服务器的ip
server_port:给shadowsocks分配的端口，默认是8388
password: 你设置的shadowsocks 密码
timeout：超时时间，默认是300秒
method： 加密方法，默认是aes-256-cfb
fast_open: 在Linux3.7+可以使用TCP_FASTOPEN 
workers:  number of workers (应该是客户端账户的个数，没理解明白)&lt;/p&gt;

&lt;p&gt;之后通过下面的命令就可以启动shadowsocks了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssserver -c /etc/shadowsocks.json -d start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样服务端的任务就已经完成了&lt;/p&gt;

&lt;p&gt;当然了我们也可以把shadowsocks设置为开机自起
把上面的命令配置到/etc/rc.local 中就可以了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160120144054744&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样，即使重启服务器，shadowsocks也会自动启动&lt;/p&gt;

&lt;p&gt;到这里服务端已经大功告成！！！&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-3&quot;&gt;客户端配置&lt;/h2&gt;

&lt;p&gt;windows系统：需要&lt;a href=&quot;https://github.com/shadowsocks/shadowsocks-windows/releases&quot;&gt;shadowsocks客户端&lt;/a&gt;，配置如图（我用的是Ubuntu的图，windows界面类似）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160120151631242&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后需要配合浏览器的代理服务器功能.&lt;/p&gt;

&lt;p&gt;如果利用Chrome插件Proxy SwitchySharp，注意一定要选择SOCKS5&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://shadowsocks.org/en/download/clients.html&quot;&gt;所有客户端的下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;~       &lt;br /&gt;
结束
–
配置比较简单，网上的资料一大堆，最后吐槽一下Baidu最近的血友病事件，一个卖假药，一个研究量子计算机，这就是Baidu和Google的差距。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Jan 2016 20:00:00 +0800</pubDate>
        <link>lcl.itmadman.cn/2016/01/10/Ubuntu%E7%A7%91%E5%AD%A6%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</link>
        <guid isPermaLink="true">lcl.itmadman.cn/2016/01/10/Ubuntu%E7%A7%91%E5%AD%A6%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</guid>
        
        <category>Ubuntu</category>
        
        
      </item>
    
      <item>
        <title>Ubuntu截图工具</title>
        <description>&lt;p&gt;使用Ubuntu已近有一段时间了,但是有时候工作中需要截图，之前用的是win qq的截图，但是大家都懂得，qq在Ubuntu 体验差的要死，还是多年以前的版本。实在不是很方便。于是就找了一下Ubuntu上好的截图方法
	方法一：其实Ubuntu是自带截图工具的（注：我用的是Ubuntu 14.04）在／usr/share/applications 中可以看到一个类似于照相机图标的应用&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160107133254164&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打开之后出现一个窗口你可以选择截取整个屏幕，或者是一个窗口，再或者某个区域，当然系统默认有使用Sreenshot的快捷键　分别为PrtSc, Alt + PrtSc, Shift + PrtSc但是系统自带的没有编辑图片的功能，比如你想模糊一些私密信息，加一些备注，系统的Screenshot就无能为力了。
方法二：Shutter
Shutter是一个第三方的截图软件需要我们手动的安装，方法很简单：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install shutter
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完之后在终端中输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cfp@cfp:~$ shutter -s
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;就可以像qq那样截图了
当然了shutter 配置了对图片的编辑功能，可以添加备注等等，非常的强大，具体安装后自己体验一下。&lt;/p&gt;

&lt;p&gt;另外就是像使用qq的截图功能一样，添加一个快捷键　Ctrl + Alt +A&lt;/p&gt;

&lt;p&gt;具体步骤：
1. 打开系统设置
2. 打开 Keyboard 键盘设置
3. 选择快捷键
4. 自定义快捷键
5. 添加快捷键
6. 编辑快捷键名称和打开命令
7. 右键设置快捷键　Ctrl + Alt +A&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160107104536475&quot; alt=&quot;步骤&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好，这样在Ubuntu上也可以噬无忌惮的截图了！&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Jan 2016 20:00:00 +0800</pubDate>
        <link>lcl.itmadman.cn/2016/01/10/ubuntu%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7/</link>
        <guid isPermaLink="true">lcl.itmadman.cn/2016/01/10/ubuntu%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7/</guid>
        
        <category>Ubuntu</category>
        
        
      </item>
    
      <item>
        <title>Android属性动画</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;Property Animation是Android3.0引入的一种功能强大的动画系统。它除了可以给普通的View添加动画效果外，还可以给对象添加效果。另外，Property Animation与Tween Animation一个最大的区别是Property Animation更改是对象的实际属性，而后者只是View的绘制效果，比如一个Button实现一个移动的动画效果，如果使用Tween Animation 的话，Button 的点击位置并不会随着动画的移动效果儿移动。换句话说在新位置Button是可能没有点击事件的。使用Property Animation可以设置下面的一些动画特性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Duration: 动画之间的间隔&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Time interpolation: 属性值的变化方式,可以表示为动画的事件函数，例如线性动画，加速动画等等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Repeat count and behavior: 动画的重复次数和重复方式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Animation sets: 动画集合&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Frame refresh delay: 帧刷新间隔，默认是10ms，但具体的速度依赖于系统的繁忙程度。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;属性动画的工作原理&lt;/h2&gt;

&lt;p&gt;图１描绘了一个假象的对象x属性的动画，它给出了该对象在屏幕水平方法的位置，在40ms内改对象移动了40个像素。每10ms记录一次对象移动的像素，这个动画是的Time interpolation是liearinterpolation,表明动画是以恒定的速度移动的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xrrm5.com1.z0.glb.clouddn.com/blog_pic_article_property_animation_1.png&quot; alt=&quot;图１&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Property Animation中，ValueAnimator是其核心类，它记录了动画自身的一些属性值。图2是其工作流程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xrrm5.com1.z0.glb.clouddn.com/blog_pic_article_property_animation_2.png&quot; alt=&quot;图２&quot; /&gt;&lt;/p&gt;

&lt;p&gt;动画在整个过程中，会根据我们当初设置的TimeInterpolator和TypeEvaluator的计算方式计算出不通的属性值，从而不断的改变属性值的大小，就会产生各式各样的动画效果。&lt;/p&gt;

&lt;p&gt;下面就通过一个实例理解一下什么是TimeInterpolator和TypeEvaluator.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TimeInterpolator&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TimeInterpolator翻译过来是插值器，插值器定义了动画变化中的属性变化规则，它根据时间比例因子计算出一个插值因子，那么什么是时间比例因子呢，简单讲就是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
时间比例因子　＝　动画已执行的时间　／　动画执行的总时间



&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而插值因子，用于设定动画是线性变化，还是非线性变化等千万中变化，你可以通过实现TimeInterpolator来实现自己的插值器(在&amp;gt;sdk22可以继承抽象类BaseInterpolator)。Android中默认的定义很多的插值器：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;AccelerateDecelerateInterpolator&lt;/p&gt;

    &lt;p&gt;在开始和结束时速度较慢&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AccelerateInterpolator&lt;/p&gt;

    &lt;p&gt;加速变化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LinearInterpolator&lt;/p&gt;

    &lt;p&gt;匀速变化&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;更多的插值器,可以在&lt;a href=&quot;https://developer.android.com/reference/android/animation/TimeInterpolator.html&quot;&gt;这里&lt;/a&gt;查看.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
//自定义插值器
class MyInterpolator implements TimeInterpolator{


    @Override
    public float getInterpolation(float input) {
        //自定义的规则
        return 0;
    }
}




&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;TypeEvaluator&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TypeEvaluator是根据插值因子去计算属性值，Android默认可以识别的类型为int, float和颜色，分别是&lt;/p&gt;

&lt;p&gt;IntEvalutor, FloatEvalutor, ArgbEvaluator.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;IntEvalutor&lt;/p&gt;

    &lt;p&gt;计算整数型&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FloatEvalutor&lt;/p&gt;

    &lt;p&gt;计算浮点型&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ArgbEvaluator&lt;/p&gt;

    &lt;p&gt;计算颜色属性&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;


//自定义TypeEvaluator
class MyTypeEvaluator implements TypeEvaluator&amp;lt;Ball&amp;gt;{


    @Override
    public Ball evaluate(float fraction, Ball startValue, Ball endValue) {
        //自己的规则
        return null;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面以三个小球的旋转效果为例，了解一下属性动画的整个实现过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xrrm5.com1.z0.glb.clouddn.com/blog_pic_article_property_animation_3.png&quot; alt=&quot;效果图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;源码可以看&lt;a href=&quot;https://github.com/chengfangpeng/BallView&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 29 Oct 2015 20:00:00 +0800</pubDate>
        <link>lcl.itmadman.cn/2015/10/29/android-animation/</link>
        <guid isPermaLink="true">lcl.itmadman.cn/2015/10/29/android-animation/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>阿里云git服务器搭建</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;首先说一下我云服务器的配置，我租的是阿里云，内存1G，带宽1M，硬盘20G，装的系统是Ubuntu14.04 LTS，这样 的配置对于个人使用我觉得绰绰有余了。之前用git都是在github上，虽然方便但是对于爱折腾的人来说远远不够，而且github上的私有库是收费的，于是决定自己搭一个自己的git服务器。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;1.需要一台装有Ubuntu的客户端机器
2.在服务端和客户端都安装git&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install git
sudo apt-get install git-core
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;3.检测一下服务端有没有安装openssh&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@iZ25eua1h3uZ:~# ps -e | grep ssh
  771 ?        00:00:00 sshd
 8407 ?        00:00:00 sshd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;因为我客户端连接服务端是通过ssh登陆的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh username@Server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;所以必须的有ssh，默认Ubuntu都会安装的，大家可以看看22端口是否被监听
4.安装Gitosis&lt;/p&gt;

&lt;p&gt;gitosis主要用来Git仓库的权限管理，默认情况下git也是有权限管理的，但是不太好用，或者用起来比较复杂，所以选择了gitosis第三方的权限      管理工具。使用Gitosis可以在GIt上面管理访问仓库的用户权限，允许某些用户访问指定的仓库,对指定的仓库拥有读写控制,gitosis 是基 于git的管理方式，服务器安装好gitosis以后，超级管理员的客户端PC就 “git  clone  gitosis” 到本地,以后的工作,比如新仓库创建,权限管理都是在 超级管理 员的PC上进的,超级管理员的PC修改gitosis的配置后，需要把修改项提交到服务器端，这样其他的用户才有权限从服务器获取到源码进行Git管理,需要注意的是新仓库的创建，权限的管理务必不要直接在Git服务器上面进行修改，超级管理员的PC才具有这些功能。&lt;/p&gt;

&lt;p&gt;可以在～下新建目录叫src&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir src  
cd ~/src  
git clone https://github.com/res0nat0r/gitosis.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;cd ~/src/gitosis&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo python setup.py install 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：如果报错：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ImportError：No module named Setuptools 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明python的安装包缺少setuptools包。&lt;/p&gt;

&lt;p&gt;解决方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install python-setuptools 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5.在server端新建用户git&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo adduser git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;6.复制客户端的ssh公钥到服务器上
建议放到tmp目录下，这样可以避免权限限制带来的问题。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scp ~/.ssh/id_rsa.pub git@Server:/tmp 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;7.服务端初始化git server&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -H -u git gitosis-init &amp;lt; /tmp/id_rsa.pub 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会看到两行输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;initilailized empty Git repository in /home/git/repositories/gitosis-admin.git/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Reinitillized existing Git repository in /home/git/repositories/gitossi-admin.git/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个步骤是给超级管理员的电脑授权，授权以后电脑B可以使用git clone命令下载gitosis-admin仓库，这个命令只需要在给超级管理员权限时使用，在增加其他的用户管理权限时，不需要这样做。&lt;/p&gt;

&lt;p&gt;修改一个文件的访问权限&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo chmod 755 /home/git/repositories/gitosis-admin.git/hooks/post-update
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;8.客户端：同步gitosis－admin到客户端开始管理git server&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone git@Server:gitosis-admin.git 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样会在当前目录下fork一个gitosis-admin的目录。里面有一个配置文件gitosisi.conf和一个存放pub key的目录keydir。&lt;/p&gt;

&lt;p&gt;9 建立新的库和授权用户&lt;/p&gt;

&lt;p&gt;如果要新建库，编辑gitosisi.conf文件，添加&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[gitosis]
[group gitosis-admin]
writable = gitosis-admin
members =  chengfangpeng@foxmail.com
[group gittest]
writable = gittest
members = chengfangpeng00@gmail.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后将修改后的内容pull到服务器上&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add -&amp;gt; git commit -&amp;gt; git push
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;新建gittest库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir gittest

cd gittest

git init

git add . 
git commit  -a  -m &quot;add new project&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;c.建立本地与服务器关联&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git remote add origin git@Server:gittest.git 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;d.提交本地代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git push origin master:refs/heads/master 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：这条命令在超级管理员的机器上面运行，将在服务器上面新创建一个仓库。
至此新的库和对应文件已经上传到server端，其他用户可以&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone git@Server:gettest.git 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;11  安装GitWeb
如果想在本地版本库看看自己项目的效果，不妨用Git 自带的一个命令，可以使用类似lighttpd这样轻量级的web服务器启动一个临时进程。
安装lightpd&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install lighttpd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git instaweb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这会在1234端口开启一个HTTPD 服务，随之在浏览器中显示该页，十分简单。关闭服务时，只需在原来的命令后面加上-stop 选项就可以了：
$ git instaweb –stop
至此完成了git server的搭建。&lt;/p&gt;

&lt;p&gt;来看看效果图分享一下成功的喜悦
&lt;img src=&quot;http://img.blog.csdn.net/20151010102442006&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2015 20:00:00 +0800</pubDate>
        <link>lcl.itmadman.cn/2015/10/10/%E9%98%BF%E9%87%8C%E4%BA%91git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</link>
        <guid isPermaLink="true">lcl.itmadman.cn/2015/10/10/%E9%98%BF%E9%87%8C%E4%BA%91git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</guid>
        
        <category>Git</category>
        
        
      </item>
    
  </channel>
</rss>
